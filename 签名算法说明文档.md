# 支付系统签名算法设计说明

## 一、算法原理

### 1.1 算法概述

签名算法基于 **Stripe 的 签名标准**，使用 **HMAC-SHA256** 加密算法生成签名。

### 1.2 算法公式

```
待签名字符串 = {时间戳}.{原始请求体（JSON字符串）}
签名值 = HMAC-SHA256(签名密钥, 待签名字符串)
请求头 = X-FlowX-Signature: t={时间戳},v1={签名值}
```

### 1.3 签名生成流程

```
步骤 1: 获取当前时间戳（Unix 时间戳，秒级）
        例如：1765964504

步骤 2: 构建待签名字符串
        格式：{时间戳}.{原始请求体（JSON字符串）}
        例如：1765964504.{"transaction_id":"TXN123","status":"success",...}

步骤 3: 使用签名密钥和 HMAC-SHA256 算法计算签名
        签名 = HMAC-SHA256(签名密钥, 待签名字符串)

步骤 4: 将签名和时间戳放入 HTTP 请求头
        请求头格式：X-FlowX-Signature: t={时间戳},v1={签名值}
        例如：X-FlowX-Signature: t=1765964504,v1=0ba6754be8af9654b16ad993d4274bf82611be7a956705d26cb23e0203eeb6df
```

### 1.4 签名验证流程

```
步骤 1: 从请求头中提取时间戳和签名值
        从请求头取出 Authorization: 'Authorization': Bearer sk_test_...
        从 X-FlowX-Signature 头中解析出 t=1765964504 和 v1=0ba6754be8af9654...

步骤 2: 检查时间戳有效性（防止重放攻击）
        如果时间戳与当前时间相差超过 5 分钟，拒绝请求

步骤 3: 使用相同的算法重新计算签名
        待签名字符串 = {时间戳}.{原始请求体}
        期望签名 = HMAC-SHA256(签名密钥, 待签名字符串)

步骤 4: 对比签名值
        如果期望签名 === 请求头中的签名，验证通过；否则拒绝请求
```

---

## 二、代码实现

### 2.1 生成签名（发起webhook时支付系统、发起交易申请时时商户端）

```javascript
const crypto = require('crypto');

function generateSignature(rawBody, signingSecret) {
  // 1. 获取时间戳
  const timestamp = Math.floor(Date.now() / 1000);
  
  // 2. 构建待签名字符串
  const payload = `${timestamp}.${rawBody}`;
  
  // 3. 计算签名
  const signature = crypto.createHmac('sha256', signingSecret)
                          .update(payload, 'utf8')
                          .digest('hex');
  
  // 4. 返回签名头
  return `t=${timestamp},v1=${signature}`;
}

// 使用示例
const callbackData = JSON.stringify({
  transaction_id: 'TXN123',
  status: 'success',
  amount: 100.00
});

const xSignature = generateSignature(callbackData, merchantSigningSecret);

// 发送 HTTP 请求
fetch(merchantNotifyUrl, {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'X-FlowX-Signature': xSignature
  },
  body: callbackData
});
```

### 2.2 验证签名（webhook时商户系统， 发起交易申请时支付系统）

```javascript
const crypto = require('crypto');

function verifySignature(rawBody, xSignatureHeader, signingSecret) {
  // 1. 解析请求头
  const parts = xSignatureHeader.split(',');
  const timestamp = parts.find(p => p.startsWith('t='))?.split('=')[1];
  const signature = parts.find(p => p.startsWith('v1='))?.split('=')[1];
  
  if (!timestamp || !signature) {
    return false;
  }
  
  // 2. 检查时间戳（防止重放攻击）
  const currentTime = Math.floor(Date.now() / 1000);
  const timeDiff = Math.abs(currentTime - parseInt(timestamp));
  if (timeDiff > 300) { // 5分钟
    return false; // 请求过期
  }
  
  // 3. 计算期望的签名
  const payload = `${timestamp}.${rawBody}`;
  const expectedSignature = crypto.createHmac('sha256', signingSecret)
                                  .update(payload, 'utf8')
                                  .digest('hex');
  
  // 4. 对比签名
  return expectedSignature === signature;
}

// 使用示例
app.post('/webhook', (req, res) => {
  const rawBody = req.rawBody; // 必须使用原始请求体
  const xSignature = req.headers['x-signature'];
  const signingSecret = 'your-signing-secret';
  
  if (verifySignature(rawBody, xSignature, signingSecret)) {
    // 签名验证通过，处理回调
    const data = JSON.parse(rawBody);
    // ... 处理业务逻辑
    res.status(200).send('OK');
  } else {
    // 签名验证失败
    res.status(401).send('Invalid signature');
  }
});
```

---

## 三、关键实现要点

1. **原始请求体处理**：必须使用 HTTP 请求的原始字节流（rawBody），不能使用解析后的 JSON 对象，因为任何字符编码或格式变化都会导致签名验证失败。

2. **时间戳验证**：通过时间戳机制防止重放攻击，通常允许 5 分钟的时间窗口。

3. **签名密钥管理**：每个商户都有独立的签名密钥（Signing Secret），密钥必须安全存储。

---